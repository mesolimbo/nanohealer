<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Nanohealer 🚑</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🚑</text></svg>">
    <style>
        /* Tighten CSS locks - fix both html and body */
        html, body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
            position: fixed;       /* NEW: also fix the root to kill rubber-banding */
            inset: 0;              /* shorthand for top/right/bottom/left: 0 */
        }
        
        body {
            display: grid;
            place-items: center;
            background-color: #880000;
            font-family: Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        /* Game container with stable viewport units */
        #gameContainer {
            aspect-ratio: 9 / 16;
            width: min(95dvw, calc(95dvh * 9 / 16));   /* NEW: stable viewport units */
            max-width: 450px;
            background: linear-gradient(to bottom, #5e0303, #020000);
            position: relative;
            touch-action: none;            /* prevents browser panning/zoom */
            -webkit-user-select: none;     /* stop long-press selection on iOS */
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block; /* remove inline-gap */
            border: 1px solid #444;
            touch-action: none; /* prevent scrolling while interacting with canvas */
            user-select: none;
            -webkit-user-select: none;
            -webkit-user-drag: none;       /* prevent image dragging */
            user-drag: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #hudContainer {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }
        
        #hud {
            color: #ffff00;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #444;
            font-size: 11px;
            font-weight: bold;
            user-select: none;
            height: 35px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 70px;
        }
        
        #scoreHud {
            color: #ffff00;
            background: rgba(0,0,0,0.7);
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid #444;
            font-size: 10px;
            font-weight: bold;
            user-select: none;
            text-align: center;
            height: 35px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            min-width: 100px;
            white-space: nowrap;
            overflow: hidden;
        }
        
        #powerupHud {
            color: #ffff00;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #444;
            font-size: 11px;
            font-weight: bold;
            user-select: none;
            height: 35px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
        }
        
        #gameContainer {
            position: relative;
        }
        
        #logo {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            user-select: none;
            pointer-events: none;
        }
        
        #gameTitle {
            width: 320px;
            height: auto;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            display: block;
        }
        
        #instructions {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            color: #DDBB99;
            font-size: 12px;
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #444;
            width: 90%;
            max-width: 420px;
            line-height: 1.3;
        }
        
        #levelInfo {
            position: absolute;
            top: 132px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            color: #ffff00;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid #444;
            width: 90%;
            max-width: 420px;
        }
        
        #scoringInfo {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            color: #DDBB99;
            font-size: 11px;
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #444;
            width: 90%;
            max-width: 420px;
            line-height: 1.2;
        }
        
        #gameOverOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 4px;
            user-select: none;
        }
        
        #gameOverTitle {
            font-size: 48px;
            color: #ff4444;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 20px;
        }
        
        #gameOverMessage {
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            margin-bottom: 30px;
        }
        
        #restartButton {
            background: #DD7799;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background 0.3s;
        }
        
        #restartButton:hover {
            background: #DD9999;
        }
        
        #victoryOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 4px;
            user-select: none;
        }
        
        #victoryTitle {
            font-size: 48px;
            color: #DDBB99;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 20px;
        }
        
        #victoryMessage {
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            margin-bottom: 10px;
        }
        
        #scoreDisplay {
            font-size: 28px;
            color: #ffff00;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        #scoreHud #scoreDisplay {
            font-size: 10px;
            margin-bottom: 0;
            text-shadow: none;
        }
        
        #victoryRestartButton {
            background: #cc132b;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background 0.3s;
        }
        
        #victoryRestartButton:hover {
            background: #cc352b;
        }
        
        #continueButton {
            background: #2a7f2a;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background 0.3s;
            margin-right: 20px;
        }
        
        #continueButton:hover {
            background: #3a8f3a;
        }
        
        .buttonContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="logo">
            <img id="gameTitle" src="/logo.svg" alt="NANOHEALER">
        </div>
        <div id="instructions">
            <strong>Repair tissue by smoothing over damaged areas</strong><br>
            Move using Arrow keys/WASD • Drag to move on mobile<br>
            Be efficient and collect 💊 to regenerate fuel
        </div>
        <div id="levelInfo">
            Level <span id="levelNumber">1</span>: <span id="levelName">Tutorial</span>
        </div>
        <div id="hudContainer">
            <div id="hud">
                <div id="motionDisplay">Fuel: <span id="motionCount">25</span></div>
            </div>
            <div id="powerupHud">
                <div id="powerupDisplay">💊: <span id="powerupCount">0</span></div>
            </div>
            <div id="scoreHud">
                <div id="scoreDisplay">Score: <span id="currentScore">0</span></div>
            </div>
        </div>
        <canvas id="gameCanvas" width="450" height="800"></canvas>
        <div id="scoringInfo">
            <strong>SCORE:</strong> Earn points by conserving fuel and collecting meds 💊
        </div>
        <div id="gameOverOverlay">
            <div id="gameOverTitle">GAME OVER</div>
            <div id="gameOverMessage">You ran out of fuel!</div>
            <button id="restartButton">RESTART GAME</button>
        </div>
        <div id="victoryOverlay">
            <div id="victoryTitle">VICTORY!</div>
            <div id="victoryMessage">All tissue repaired!</div>
            <div id="scoreDisplay">Score: <span id="finalScore">0</span></div>
            <div class="buttonContainer">
                <button id="continueButton" style="display: none;">CONTINUE</button>
                <button id="victoryRestartButton">PLAY AGAIN</button>
            </div>
        </div>
    </div>
    
    <script>
        let levelsData = null;
        let currentLevel = 0;
        let currentLevelData = null;
        let totalScore = 0;
        
        // Load levels data
        async function loadLevels() {
            try {
                const response = await fetch('./levels.dat');
                if (!response.ok) {
                    throw new Error(`Failed to fetch levels: ${response.status} ${response.statusText}`);
                }
                levelsData = await response.json();
                
                // Validate levels data
                if (!levelsData || !levelsData.levels || !Array.isArray(levelsData.levels) || levelsData.levels.length === 0) {
                    throw new Error('Invalid levels data format');
                }
                
                console.log('Loaded levels:', levelsData);
                initializeLevel(0);
            } catch (error) {
                console.error('Failed to load levels:', error);
                showLoadError(error.message);
            }
        }
        
        function showLoadError(errorMessage) {
            // Hide the game elements and show error message
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('hudContainer').style.display = 'none';
            document.getElementById('scoringInfo').style.display = 'none';
            document.getElementById('levelInfo').style.display = 'none';
            
            // Create error overlay
            const errorOverlay = document.createElement('div');
            errorOverlay.id = 'errorOverlay';
            errorOverlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 200;
                color: #ff4444;
                text-align: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            errorOverlay.innerHTML = `
                <div style="font-size: 36px; font-weight: bold; margin-bottom: 20px; color: #ff4444;">
                    ⚠️ Game Error
                </div>
                <div style="font-size: 18px; margin-bottom: 10px; color: #ffffff;">
                    Failed to load game levels
                </div>
                <div style="font-size: 14px; margin-bottom: 30px; color: #cccccc; max-width: 400px;">
                    ${errorMessage}
                </div>
                <div style="font-size: 12px; color: #888888;">
                    Please check that levels.dat is present and valid
                </div>
            `;
            
            document.getElementById('gameContainer').appendChild(errorOverlay);
        }
        
        function initializeLevel(levelIndex) {
            currentLevel = levelIndex;
            const originalLevel = levelsData.levels[levelIndex];
            // Create a deep copy of the level data to avoid modifying the original
            currentLevelData = {
                name: originalLevel.name,
                fuelLimit: originalLevel.fuelLimit,
                grid: [...originalLevel.grid]  // Create a new array copy
            };
            MAX_MOVES = currentLevelData.fuelLimit;
            document.getElementById('levelNumber').textContent = levelIndex + 1;
            document.getElementById('levelName').textContent = originalLevel.name;
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const TILE_WIDTH = 44;
        const TILE_HEIGHT = 22;
        const GRID_SIZE = 10;
        
        const COLORS = {
            0: '#DDBB99', // flesh color for empty tiles
            1: '#CC9988',
            2: '#bb7f77',
            3: '#cc352b'
        };
        
        const player = {
            x: 0,
            y: 0
        };
        
        let MAX_MOVES = 25;
        let motionCounter = 0;
        let gameOver = false;
        let gameWon = false;
        let powerupsCollected = 0;
        
        function drawIsometricTile(x, y, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = '#996644';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + TILE_WIDTH / 2, y + TILE_HEIGHT / 2);
            ctx.lineTo(x, y + TILE_HEIGHT);
            ctx.lineTo(x - TILE_WIDTH / 2, y + TILE_HEIGHT / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        function drawLeftSideTile(x, y, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = '#755234';
            ctx.lineWidth = 1;
            
            // Left side face (vertical rectangle in isometric view)
            ctx.beginPath();
            ctx.moveTo(x - TILE_WIDTH / 2, y + TILE_HEIGHT / 2);
            ctx.lineTo(x - TILE_WIDTH / 2, y + TILE_HEIGHT / 2 + TILE_HEIGHT);
            ctx.lineTo(x, y + TILE_HEIGHT + TILE_HEIGHT);
            ctx.lineTo(x, y + TILE_HEIGHT);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        function drawRightSideTile(x, y, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = '#996644';
            ctx.lineWidth = 1;
            
            // Right side face (vertical rectangle in isometric view)
            ctx.beginPath();
            ctx.moveTo(x + TILE_WIDTH / 2, y + TILE_HEIGHT / 2);
            ctx.lineTo(x + TILE_WIDTH / 2, y + TILE_HEIGHT / 2 + TILE_HEIGHT);
            ctx.lineTo(x, y + TILE_HEIGHT + TILE_HEIGHT);
            ctx.lineTo(x, y + TILE_HEIGHT);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        function drawEmojiShadow(gridX, gridY, shadowColor = '#996644', shadowWidth = 10, shadowHeight = 4) {
            const gridWidth = GRID_SIZE * TILE_WIDTH;
            const gridHeight = GRID_SIZE * TILE_HEIGHT;
            const offsetX = canvas.width / 2;
            const offsetY = (canvas.height - gridHeight) / 2 + gridHeight / 4 - (TILE_HEIGHT * 3);
            
            const isoPos = gridToIso(gridX, gridY);
            const centerX = offsetX + isoPos.x;
            const centerY = offsetY + isoPos.y + TILE_HEIGHT - 2;
            
            ctx.save();
            ctx.fillStyle = shadowColor;
            ctx.scale(1, 0.5);
            
            // Create a unified radial gradient shadow
            const gradient = ctx.createRadialGradient(centerX, centerY * 2, 0, centerX, centerY * 2, shadowWidth * 2);
            gradient.addColorStop(0, shadowColor);
            gradient.addColorStop(0.3, shadowColor + '88');
            gradient.addColorStop(0.7, shadowColor + '33');
            gradient.addColorStop(1, shadowColor + '00');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY * 2, shadowWidth * 1.8, shadowHeight * 1.8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function gridToIso(gridX, gridY) {
            const isoX = (gridX - gridY) * TILE_WIDTH / 2;
            const isoY = (gridX + gridY) * TILE_HEIGHT / 2;
            return { x: isoX, y: isoY };
        }
        
        function healTile(x, y) {
            const gridIndex = y * GRID_SIZE + x;
            const currentTile = currentLevelData.grid[gridIndex];
            
            if (currentTile === 4) {
                currentLevelData.grid[gridIndex] = 0;
                motionCounter = Math.max(0, motionCounter - 10);
                powerupsCollected++;
                return true;
            } else if (currentTile > 0 && currentTile < 4) {
                currentLevelData.grid[gridIndex] = currentTile - 1;
                return true;
            }
            return false;
        }
        
        function updateHUD() {
            const remainingMoves = MAX_MOVES - motionCounter;
            document.getElementById('motionCount').textContent = remainingMoves;
            document.getElementById('powerupCount').textContent = powerupsCollected;
            document.getElementById('currentScore').textContent = totalScore.toLocaleString();
        }
        
        function checkVictory() {
            for (let i = 0; i < currentLevelData.grid.length; i++) {
                const tile = currentLevelData.grid[i];
                if (tile > 0 && tile !== 4) {
                    return false;
                }
            }
            return true;
        }
        
        function showGameOverMessage() {
            document.getElementById('gameOverOverlay').style.display = 'flex';
        }
        
        function showVictoryMessage() {
            const remainingMoves = MAX_MOVES - motionCounter;
            const powerupBonus = powerupsCollected * 100;
            const levelScore = (remainingMoves * 100) + powerupBonus;
            totalScore += levelScore;
            document.getElementById('finalScore').textContent = totalScore.toLocaleString();
            
            console.log('Victory! Current level:', currentLevel, 'Total levels:', levelsData.levels.length);
            
            // Show continue button if not on last level, hide restart button
            const continueButton = document.getElementById('continueButton');
            const restartButton = document.getElementById('victoryRestartButton');
            const victoryTitle = document.getElementById('victoryTitle');
            const victoryMessage = document.getElementById('victoryMessage');
            
            if (currentLevel < levelsData.levels.length - 1) {
                console.log('Showing continue button');
                // Intermediate level messages
                victoryTitle.textContent = 'SUCCESS!';
                victoryMessage.textContent = 'Infection treated!';
                continueButton.style.display = 'block';
                restartButton.style.display = 'none';
            } else {
                console.log('Showing final restart button');
                // Final level messages
                victoryTitle.textContent = 'VICTORY!';
                victoryMessage.textContent = 'All tissue repaired!';
                continueButton.style.display = 'none';
                restartButton.style.display = 'block';
                restartButton.textContent = 'PLAY AGAIN';
            }
            
            document.getElementById('victoryOverlay').style.display = 'flex';
        }
        
        function resetGame() {
            motionCounter = 0;
            gameOver = false;
            gameWon = false;
            powerupsCollected = 0;
            totalScore = 0;  // Reset total score
            player.x = 0;
            player.y = 0;
            
            initializeLevel(0);  // Reset to first level - this creates a fresh copy
            
            document.getElementById('gameOverOverlay').style.display = 'none';
            document.getElementById('victoryOverlay').style.display = 'none';
            updateHUD();
            render();
            
            // Heal starting tile
            healTile(player.x, player.y);
        }
        
        function continueToNextLevel() {
            console.log('Continue called. Current level before:', currentLevel);
            if (currentLevel < levelsData.levels.length - 1) {
                motionCounter = 0;
                gameOver = false;
                gameWon = false;
                powerupsCollected = 0;
                player.x = 0;
                player.y = 0;
                
                console.log('Advancing to level:', currentLevel + 1);
                initializeLevel(currentLevel + 1);  // This creates a fresh copy
                console.log('After init - Current level:', currentLevel);
                
                document.getElementById('victoryOverlay').style.display = 'none';
                updateHUD();
                render();
                
                // Heal starting tile
                healTile(player.x, player.y);
            } else {
                console.log('Already at last level, cannot continue');
            }
        }
        
        function movePlayer(dx, dy) {
            if (gameOver || gameWon) return;
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                console.log("Moving to:", newX, newY);
                player.x = newX;
                player.y = newY;
                motionCounter++;
                console.log("Tile before heal:", currentLevelData.grid[player.y * GRID_SIZE + player.x]);
                healTile(player.x, player.y);
                console.log("Tile after heal:", currentLevelData.grid[player.y * GRID_SIZE + player.x]);
                
                if (checkVictory()) {
                    gameWon = true;
                    showVictoryMessage();
                } else if (motionCounter >= MAX_MOVES) {
                    gameOver = true;
                    showGameOverMessage();
                }
                
                updateHUD();
                render();
            }
        }
        
        function drawAllEmojiShadows() {
            console.log("Drawing shadows - Player at grid:", player.x, player.y);
            
            // Draw shadow for ambulance
            drawEmojiShadow(player.x, player.y, '#996644', 10, 4);
            
            // Find and draw shadow for powerup pill
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const gridIndex = row * GRID_SIZE + col;
                    const tileType = currentLevelData.grid[gridIndex];
                    if (tileType === 4) {
                        drawEmojiShadow(col, row, '#996644', 8, 3);
                    }
                }
            }
        }
        
        function drawPlayer() {
            const gridWidth = GRID_SIZE * TILE_WIDTH;
            const gridHeight = GRID_SIZE * TILE_HEIGHT;
            
            const offsetX = canvas.width / 2;
            const offsetY = (canvas.height - gridHeight) / 2 + gridHeight / 4 - (TILE_HEIGHT * 3);
            
            const isoPos = gridToIso(player.x, player.y);
            const screenX = offsetX + isoPos.x;
            const screenY = offsetY + isoPos.y + TILE_HEIGHT / 2;
            
            ctx.save();
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText('🚑', screenX, screenY);
            ctx.restore();
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const gridWidth = GRID_SIZE * TILE_WIDTH;
            const gridHeight = GRID_SIZE * TILE_HEIGHT;
            
            const offsetX = canvas.width / 2;
            const offsetY = (canvas.height - gridHeight) / 2 + gridHeight / 4 - (TILE_HEIGHT * 3);
            
            // Draw 3D base tiles first (underneath main board)
            draw3DBaseTiles(offsetX, offsetY);
            
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const gridIndex = row * GRID_SIZE + col;
                    const tileType = currentLevelData.grid[gridIndex];
                    const color = COLORS[tileType] || COLORS[0];
                    
                    const isoPos = gridToIso(col, row);
                    const screenX = offsetX + isoPos.x;
                    const screenY = offsetY + isoPos.y;
                    
                    drawIsometricTile(screenX, screenY, color);
                    
                    if (tileType === 4) {
                        // Just draw pill emoji (shadow will be drawn later)
                        ctx.save();
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#fff';
                        ctx.fillText('💊', screenX, screenY + TILE_HEIGHT / 2);
                        ctx.restore();
                    }
                }
            }
            
            // Draw shadows for all emojis (before drawing the emojis themselves)
            drawAllEmojiShadows();
            drawPlayer();
        }
        
        function draw3DBaseTiles(offsetX, offsetY) {
            // Consistent colors - same across all rows
            const leftSideColor = '#8c6f4a';   // Dark consistent color for left side
            const rightSideColor = '#eddbcb';  // Light consistent color for right side
            
            // Draw 3 rows of tiles on each side
            for (let row = 0; row < 3; row++) {
                // Left side tiles
                for (let i = 0; i < 10; i++) {
                    const isoPos = gridToIso(i, 9);  // Bottom edge of main board
                    const screenX = offsetX + isoPos.x;
                    const screenY = offsetY + isoPos.y + (row * TILE_HEIGHT);
                    drawLeftSideTile(screenX, screenY, leftSideColor);
                }
                
                // Right side tiles
                for (let i = 0; i < 10; i++) {
                    const isoPos = gridToIso(9, i);  // Right edge of main board
                    const screenX = offsetX + isoPos.x;
                    const screenY = offsetY + isoPos.y + (row * TILE_HEIGHT);
                    drawRightSideTile(screenX, screenY, rightSideColor);
                }
            }
        }
        
        document.addEventListener('keydown', (event) => {
            switch(event.key.toLowerCase()) {
                case 'a':
                case 'arrowleft':
                    movePlayer(-1, 0);
                    break;
                case 's':
                case 'arrowdown':
                    movePlayer(0, 1);
                    break;
                case 'd':
                case 'arrowright':
                    movePlayer(1, 0);
                    break;
                case 'w':
                case 'arrowup':
                    movePlayer(0, -1);
                    break;
                case 'r':
                case 'enter':
                    if (gameOver) {
                        resetGame();
                    } else if (gameWon) {
                        // Check if continue button is visible (not on last level)
                        const continueButton = document.getElementById('continueButton');
                        if (continueButton.style.display === 'block') {
                            continueToNextLevel();
                        } else {
                            resetGame();
                        }
                    }
                    break;
            }
        });
        
        // Touch/drag controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let isDragging = false;
        const minDragDistance = 30;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            isDragging = false;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!isDragging) return;
            
            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            
            // Only move if drag distance is significant
            if (Math.abs(deltaX) < minDragDistance && Math.abs(deltaY) < minDragDistance) {
                return;
            }
            
            // Determine direction matching isometric grid (45° rotated)
            const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
            
            // Isometric directions aligned with visual grid:
            // Right: 45° (down-right on screen)
            // Down: 135° (down-left on screen)  
            // Left: -135° or 225° (up-left on screen)
            // Up: -45° or 315° (up-right on screen)
            
            if ((angle >= 22.5 && angle <= 67.5)) {
                // Touch down-right → isometric right
                movePlayer(1, 0);
            } else if ((angle >= 112.5 && angle <= 157.5)) {
                // Touch down-left → isometric down
                movePlayer(0, 1);
            } else if ((angle >= -157.5 && angle <= -112.5)) {
                // Touch up-left → isometric left
                movePlayer(-1, 0);
            } else if ((angle >= -67.5 && angle <= -22.5)) {
                // Touch up-right → isometric up
                movePlayer(0, -1);
            } else if (angle >= -22.5 && angle <= 22.5) {
                // Pure horizontal right → closest isometric (right)
                movePlayer(1, 0);
            } else if (angle >= 67.5 && angle <= 112.5) {
                // Pure vertical down → closest isometric (down)
                movePlayer(0, 1);
            } else if (angle >= 157.5 || angle <= -157.5) {
                // Pure horizontal left → closest isometric (left)
                movePlayer(-1, 0);
            } else if (angle >= -112.5 && angle <= -67.5) {
                // Pure vertical up → closest isometric (up)
                movePlayer(0, -1);
            }
        });
        
        document.getElementById('restartButton').addEventListener('click', () => {
            resetGame();
        });
        
        document.getElementById('victoryRestartButton').addEventListener('click', () => {
            resetGame();
        });
        
        document.getElementById('continueButton').addEventListener('click', () => {
            continueToNextLevel();
        });
        
        // Initialize game after loading levels
        async function initGame() {
            await loadLevels();
            console.log("Game starting - Player at:", player.x, player.y);
            console.log("Starting tile type:", currentLevelData.grid[player.y * GRID_SIZE + player.x]);
            healTile(player.x, player.y);
            console.log("After healing - Tile type:", currentLevelData.grid[player.y * GRID_SIZE + player.x]);
            updateHUD();
            render();
        }
        
        // Start the game
        initGame();
        
        // Document-level scroll blocking to catch gestures that start outside game area
        const allowClickTargets = (el) =>
            el.tagName === 'BUTTON' || (el.closest && el.closest('button'));

        const hardBlock = (e) => {
            if (!allowClickTargets(e.target)) e.preventDefault();
        };

        // Block page-level scroll no matter where the gesture starts
        document.addEventListener('touchstart', hardBlock, { passive: false });
        document.addEventListener('touchmove', hardBlock, { passive: false });
        
        // Guard against pinch-zoom / gesture events on iOS
        window.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });
        window.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
        window.addEventListener('gestureend', e => e.preventDefault(), { passive: false });
    </script>
</body>
</html>
